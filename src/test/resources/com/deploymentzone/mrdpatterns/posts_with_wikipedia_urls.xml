<row Id="20839" PostTypeId="2" ParentId="20734" CreationDate="2008-08-21T19:12:56.270" Score="2" ViewCount="0" Body="&lt;p&gt;BSTs make the world go round, as said by Micheal. If you're looking for a good tree to implement, take a look at &lt;a href=&quot;http://en.wikipedia.org/wiki/AVL_tree&quot; rel=&quot;nofollow&quot;&gt;AVL trees&lt;/a&gt; (Wikipedia). They have a balancing condition, so they are guaranteed to be O(logn). This kind of searching efficiency makes it logical to put into any kind of indexing process. The only thing that would be more efficient would be a hashing function, but those get ugly quick, fast, and in a hurry. Also, you run into the &lt;a href=&quot;http://en.wikipedia.org/wiki/Birthday_paradox&quot; rel=&quot;nofollow&quot;&gt;Birthday Paradox&lt;/a&gt; (also known as the pigeon-hole problem).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;What textbook are you using? We used &lt;a href=&quot;http://www.amazon.com/Data-Structures-Algorithm-Analysis-Java/dp/0321370139&quot; rel=&quot;nofollow&quot;&gt;Data Structures and Analysis in Java&lt;/a&gt; by Mark Allen Weiss. I actually have it open in my lap as i'm typing this. It has a great section about Red-Black trees, and even includes the code necessary to implement all the trees it talks about.&lt;/p&gt;&#xA;" OwnerUserId="50" LastActivityDate="2008-08-21T19:12:56.270" />
